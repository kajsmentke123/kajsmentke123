int same_case(const char a, const char b){
	if(islower(a)){
		if(islower(b)){
			return 1;
		}
		return 0;
	}
	if(isuper(a)){
		if(isuper(b)){
			return 1;
		}
		return 0;
	}
	return -1;
}

int binary_num(const int num){
	if(num<-1000){
		return -1;
	}
	else if(num>1000){
		return -1;
	}
	else if(num==0){
		return 1;
	}
	else if(num==1){
		return 1;
	}
	return 0;
}

//odd - 5 bodov
int odd(const int num){
	int a, mod;

	mod = num%2;

	if(mod == 0){
		a = 0;
	}
	else{
		a = 1;
	}

	return a;
}


//signs - 5 bodov
int signs(const int a, const int b){
	if((a>0 && b>0) || (a<0 && b<0)){
		return 1;
	}
	if(a==0 || b==0){
		return 0;
	}
	return -1;
}

//even - 5 bodov
int even(const int num){
	if(num%2==0){
		return 1;
	}
	else{
		return 0;
	}
}

//is_white - 5 bodov
int is_white(const char c){
	if(c==' ' || c=='\n' || c=='\t'){
		return 1;
	}
	else{
		return 0;
	}
}

//karel_asleep - 5 bodov
int karel_asleep(const int position){
	if(position == '|'){
		return 0;
	}
	if(position == '-'){
		return 1;
	}
	return -1;
}

int karel_turn(const int degree){

	int mod=0;
	int turn=0;

	if(degree >= 0){
		mod = degree%90;
		if(mod == 0){
			turn = degree/90;
		}
		else{
			turn = -1;
		}
	}
	else{
		turn = -1;
	}


	return turn;
}



//is_triangle - 5 bodov
int is_triangle(const int alpha, const int beta, const int gamma){
	if( alpha<1 || beta<1 || gamma<1 ){
		return -1;
	} 
	if((alpha+beta+gamma)== 180){
		return 1;
	}
	return 0;
}

//sum_greater - 5 bodov
int sum_greater(const int a, const int b, const int c){
	if(a<b && a<c){
		return b+c;
	}
	if(b<a && b<c){
		return a+c;
	}
	return a+b;
}

//ul - 5 bodov
char ul(const char c){
	if(isupper(c)){
		return tolower(c);
	}
	return toupper(c);	
}

	//isFibDigits - 10 bodov	       
	int isFibDigits(const int *digits, const int size){
        int j = 0;
	        int num = 0;
        for(int i = size-1; i>=0; i--) {
	                num += digits[i] * pow(10,j);
	        j++;
	    }
	 
	        int num1 = 0;
	        int num2 = 1;
	 
	        while(1) {
	      if(num2 == num)
	        return 1;
	      if(num2 > num)
	        return 0;
	     
	      int tmp = num2;
	      num2 = num1 + num2;
	      num1 = tmp;
	    }
	}


int discriminant(const int a, const int b, const int c){
	return (b*b - 4*a*c);
	}
	
int isRightTriangle(const int a, const int b, const int c){
	int arr[3];
	arr[0] = a;
	arr[1] = b;
	arr[2] = c;
	for(int i = 1; i < 3; i++) {
	for(int j = 0; j < 2; j++) {
	if(arr[i] < arr[j]) {
	int tmp = arr[i];
	arr[i] = arr[j];
	arr[j] = tmp;
	        }	    
	}
}
		return (arr[2]*arr[2] == (arr[0]*arr[0] + arr[1]*arr[1]));
	}
	
int min(const int a, const int b, const int c){
	int arr[3];
	arr[0] = a;
	arr[1] = b;
	arr[2] = c;
	   for(int i = 1; i < 3; i++) {
	      for(int j = 0; j < 2; j++) {
	        if(arr[i] < arr[j]) {
	          int tmp = arr[i];
	          arr[i] = arr[j];
	          arr[j] = tmp;
	        }
	      }
	    }
	 
	        return arr[0];
	}
	
char last(const char* string){
	int i = 0;
	 for(i=0; string[i] != ‘\0‘; i++);
	 
	        return string[i-1];
	}
	
	
int isPalindrome(const char* string){
	 char str[strlen(string)];
	 int j = 0;
	 for(int i = strlen(string)-1; i >= 0; i--) {
               str[j] = string[i];
	        j++;
	        }
	        str[j] = ‘\0‘;
	 
	        return(strcmp(str, string) == 0);
	}

int n_fib(const int n){

	if(n<1 || n>575) {
	return -1;
          }
	int first = 0, second = 1, next, c;
	int counter = n;

	for (c=0; c<=n; c++){
	if (c<=1)
		next =c;
	else{
	next= first+second;
	first = second;
	second = next;
	counter--;

	}
}
return next;
return -1;
}
	
int isFib(const int num){
	int num1 = 0;
        int num2 = 1;
	 
	 while(1) 
	 {
	 if(num2 == num)
	        return 1;
	      if(num2 > num)
	        return 0;
	     
	      int tmp = num2;
	      num2 = num1 + num2;
	      num1 = tmp;
	    }
	}

	
	
float *roots(const int a, const int b, const int c){
	        int d = b*b - 4*a*c;
	 
	        float x1 = 0.0f;
	        float x2 = 0.0f;
	        if(d == 0) {
	                x1 = (float) (-b)/(2*a);
	        x2 = (float) (-b)/(2*a);
	    } else if (d > 0) {
	        x1 = (float) (-b - sqrt(d))/(2*a);
	        x2 = (float) (-b + sqrt(d))/(2*a);
		} else {
	      return NULL;
	    }
 
	        float* arr = (float*) malloc(2*sizeof(float));
	 
	        arr[0] = x1;
	        arr[1] = x2;
	 
	        return arr;
	}

int count_positives(const int size, const int array[]){
	int count = 0;

	for(int i = 0; i < size; i++){
		if(array == NULL){
			count = -1;
		}
		else if(array[i]>0){
					count++;
		}
	}
	return count;
}

int vowels_count(const char string[]){

	int back = 0;
	int count = 0;

	if(string != NULL){
		for(int i = 0; string[i]!='\0'; i++){
			if(string[i] == 'a' || string[i] == 'e' || string[i] == 'i' || string[i] == 'o' || string[i] == 'u' || string[i] == 'y' ||
			   string[i] == 'A' || string[i] == 'E' || string[i] == 'I' || string[i] == 'O' || string[i] == 'U' || string[i] == 'Y'){

				count++;
			}
		}
		back = count;
	}
	else{
		back = -1;
	}

	return back;
}



int is_prime(const int num){

	int mod = 0, count = 0;

	for(int i = 1; i <= num; i++){
		mod = num%i;
		if(mod == 0){
			count++;
		}
	}
	if(count == 2){
		return 1 ;
	}
	else{
		return 0;
	}
}
 
long multiples(const int below){

	int mod2 = 0, mod1 = 0, sum = 0;

	if(below>0 && below<=10000){
		for(int i = 1; i < below ; i++){
			mod1 = i % 3;
			mod2 = i % 5;
			if(mod1 == 0 || mod2 == 0){
				sum += i;
			}
		}
	}
	else{
		sum = -1;
	}

	return sum;
}

int is_in_array(const int num, const int size, const int array[]){
	int IsHere = 0,NotHere = 0,not = 0;
	if(array != NULL){
		for(int i = 0; i < size ; i++){
			if(num == array[i]){
				IsHere= 1;
			}
			else{
				NotHere++;
			}
		}
	}
	else{
		not = -1;
	}

	if(IsHere == 1){
		not = 1;
	}
	else if(NotHere>1){
		not = 0;
	}
	return not;
} 


int min_2d(const int size, int array[][size]){
	int value = 0;

	if(array != NULL){
		for(int i = 0; i < size; i++){
			for(int j = 0; j < size; j++){
				if(value>array[i][j]){
					value = array[i][j];
				}
			}
		}
	}
	else{
		value = -1;
	}

	return value;
}  

int count_whites(const char string[]){
	if(string == NULL){
		return -1;
	}
	int len=strlen(string);
	int count=0;
	if(string>0){
		for(int i=0; i<len; i++){
			//if(isspace(string[i])){
			if(string[i]==' ' || string[i]=='\n' || string[i]=='\t'){
				count++;
			}
		}
	}
	return count;
}

void change_whites(char string[]){

	if(string != NULL){
		for(int i = 0;string[i]!='\0';i++){
			if(string[i]==' ' || string[i]=='\n'){
				string[i]='.';
			}
		}
	}
}  


int sum_digits(const int n){
	int num = 0, mod = 0, c, f;
	if(n > 0){
		num = 1;
		for(int i = 0; i < n; i++){
			if(i > 1 && i <= 5){
				mod = num;
			}
			if(i>5 && i < 15){
				mod = 0;
				c = num;
				while(f != 2){
					mod += c%10;
					c=c/10;
					f++;
				}
			}
			if(i>14){
				mod = 0;
				c = num;
				while(f != 3){
					mod += c%10;
					c=c/10;
					f++;
				}
			}
			f = 0;
			num = num + mod;
		}
	}
	else{
		num = 0;
	}

	return num;
}

int count_leap_year(const int size, const int array[]){
	int count = 0;

	if(array != NULL){
		for(int i = 0 ; i < size ; i++){
	if (((array[i] % 4 == 0) && (array[i] % 100!= 0)) || (array[i]%400 == 0)){
			count++;
			}
		}
	}
	else{
		count = -1;
	}

	return count;
} 

void unique(int a, int arr[]){
	int num = 0, position = 0,c, pole[1000], count = 0;

	for(int v=0;v<a;v++){
		printf("%d ",arr[v]);
	}

	for(int i = 0; i < a; i++){
		for(int j = 0; j < a; j++){
			if(arr[i]==arr[j]){
				num++;
			}
		}
		if(num == 1 ){
			pole[count] = i;
			count++;
		}
		num = 0;
	}
	puts("\n");
	for(int b = 0; b <a ; b++){
		for (c =pole[b]-position; c < a - 1; c++){
			arr[c] = arr[c+1];
		}
		position++;
	}
	for(int b = 0; b <a-count ; b++){
		printf("%d ",arr[b]);
	}
}
 
void human(int c){
	int year = (12*30*24*60*60), rok = 0;
	int month = (30*24*60*60), mesiac = 0;
	int day = (24*60*60), den = 0;
	int hour = (60*60), hodina = 0;
	int minute = (60), minuta = 0;
	int secound = (1), sekunda = 0;
	int num = c;

	while(num!=0){
		if(year<=num){
			rok = num/year;
			num = num - (year*rok);
		}
		else if(month <=num){
			mesiac= num/ month;
			num = num - (month*mesiac);
		}
		else if(day <=num){
			den = num/day;
			num = num - (day*den);
		}
		else if(hour <=num){
			hodina= num/ hour;
			num = num - (hour*hodina);
		}
		else if(minute <=num){
			minuta = num/ minute;
			num = num - (minute*minuta);
		}
		else{
			sekunda = num/ secound;
			num = num - (secound*sekunda);
		}
	}
	printf("%d rok %d mesiac %d den %d hodina %d minuta %d sekunda", rok, mesiac, den, hodina, minuta, sekunda);
 } 

void worker(int a, int b){

	int mod;

	for(int i = a+1; i < b; i++){
		mod = i%7;
		if(mod == 3 || mod == 2){
			printf("%d\n",i);
		}
	}
}

void bubbleSort(double arr[], int n){
   int i, j, swap;
   for (i = 0; i < n-1; i++){
       for (j = 0; j < n-i-1; j++){
           if (arr[j] > arr[j+1]) {
        	   swap = arr[j];
        	   arr[j]   = arr[j+1];
        	   arr[j+1] = swap;
           }
       }
   }
}

double median(int count, double pole[]){
	int mod,num;
	double median;

	bubbleSort(pole,count);

	for(int i = 0;i < count; i++){
			printf("%f\n",pole[i]);
	}

	mod=count%2;

	if(mod == 0){
		num = count / 2;
		median = (pole[num-1]+pole[num])/2;
	}
	else{
		num = count/2;
		median = pole[num];
	}

	return median;
}

void select_numbers(int array[], int N) {
	int i;
	int max1, max2, max3,pos1,pos2,pos3;
	max1 = 0;
	max2 = 0;
	max3 = 0;
	for (i = 0; i < N; i++) {
		if (array[i] > max1) {
			max1 = array[i];
			pos1 = i+1;
		}
	}
	for (i = 0; i < N; i++) {
		if (array[i] > max2 && array[i] < max1) {
			max2 = array[i];
			pos2 = i+1;
		}
	}
	for (i = 0; i < N; i++) {
		if (array[i] > max3 && array[i] < max1 && array[i] < max2) {
			max3 = array[i];
			pos3 = i+1;
		}
	}
	printf("%d %d %d\n %d %d %d", max1, max2, max3, pos1, pos2, pos3);

}

int find_first_A(const char string[]){
	
	if(string==NULL){
		return -1;
	}
	int i=0;
	while(string[i] !='a' && string[i] !='a' && string[i] !='A' && string[i] !='\0'){
		++i;
		
	}
	if(string[i]=='\0'){
		return -1;
	}
	return i;
}














	 


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
